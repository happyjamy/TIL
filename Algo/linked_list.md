# Linked List

- k번째 원소를 확인/변경하기 위해 O(k) 필요
- 임의의 위치에 원소를 추가/제거는 O(1)
  - 단! 임의의 위치 주소를 안다는 전제. 즉 81을 21 뒤에 추가하고 싶다면, (21,주소)면 21의 주소값을 줘야 됨. 그냥 21의 주소를 준 것이 아니라 그냥 84라는 원소를 세 번째 원소 뒤에 추가하라는 명령의 경우에는, 세 번째 원소까지 찾아가야 하는 시간이 추가로 걸려서 O(1)이라고 말할 수 없음.
- 원소들이 메모리상에 연속 X, cache hit rate 낮지만 할당이 쉬움
  - cache hit rate? 캐시 적중률. 원하는 정보가 캐시 메모리에 기억되어 있을 때 적중(Hit)되었다고 하고, 기억되어 있지 않으면 실패했다고 한다. 적중률은 캐시 기억장치가 있는 컴퓨터의 성능을 나타내는 척도로 이용되며, 적중률이 0.95~0.99일 때 우수.

> - 텍스트에디터 -> 임의의 위치에 글자를 추가 많이해야해서.
>   => 임의의 위치에서 원소를 추가하거나 임의 위치의 원소를 제거하는 연산을 많이 해야 할 경우에는 연결 리스트의 사용

## 종류

1. 단일 연결 리스트

- 다음 원소의 주소만을 들고 있는 연결 리스트

2. 이중 연결 리스트

- 자신의 이전 원소와 다음 원소의 주소를 둘 다 들고 있는 연결 리스트

3. 원형 연결 리스트

- 끝이 처음과 연결되어 있는 연결 리스트 (단일,이중 둘다 O)

## 배열 vs 연결리스트

![배열 연결리스트 비교](https://user-images.githubusercontent.com/78072370/232094369-c8fe3ff3-b7b7-4c68-b405-91d53a3ead1c.png)
배열과 연결 리스트는 메모리 상에 원소를 놓는 방법은 다르다고 해도 어찌됐든 원소들 사이의 선후 관계가 일대일로 정의 됨. 즉, 원소들 사이에서 첫 번째 원소, 두 번째 원소, … 이런 개념이 존재.

연결 리스트는 배열의 공간의 크기를 미리 할당 해줘야 한다는 단점을 해결할 수 있다. 단, 저장 측면에서는 비효율적이다.

## 추가/삭제 구현

-**추가**

unused = 실제 배열 인덱스

insert(추가하고싶은 주소 앞 주소,data)

1. unused 주소에 새 원소 생성
2. 새 원소의 pre 값에 삽입할 주소 넣기
3. 새 원소의 nxt 값에 삽입할 주소의 nxt 값 넣기
4. 이전 원소의 nxt 값에 다음 원소의 pre 값에 새 원소 주소 넣기
5. unused 1 증가
6. 맨 마지막에서 추가할때 대비

**삭제**

erase(삭제할 주소)

1. 이전 원소의 nxt를 삭제할 원소의 nxt로 바꿈
2. 다음 원소의 pre를 삭제할 원소의 pre로 바꿈
3. 맨 마지막 원소 지울때 대비

**맨 앞 원소는 더미원소 때문에 안전**
