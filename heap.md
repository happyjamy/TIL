# Heap

- 최댓값 최솟값을 찾는 연산을 빠르게 수행하기 위해 고안된 자료구조
- 힙에서는 가장 높은(혹은 가장 낮은) 우선순위를 가지는 노드가 항상 **루트노드**에 오기때문에, 이를 응용해 우선순위 큐 구현 가능
- (이진힙은) 완전 이진트리의 일종
- 반정렬 상태(느슨한 정렬 상태)를 유지
  - 부모 노드의 키값이 자식 노드의 키 값보다 항상 큰(작은) 이진 트리
- 힙트리는 중복된 값 허용 (이진탐색트리는 허용X)
- 각 노드의 자식노드의 최대개수는 종류에 따라 다르지만, 대부분 자식노드의 개수가 최대 2개인 이진힙(binary heap) 사용

</br>

### Priority Queue(우선 순위 큐)

큐에 우선순위 개념을 적용 시킨 자료구조

> **Queue**는 먼저 들어간 데이터가 먼저 나옴. (FIFO)
> 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용.
>
> **사용**
>
> - 프린터의 출력 처리
> - 윈도 시스템의 메시지 처리기
> - 프로세스 관리

> **Stack**은 나중에 들어간 데이터가 먼저 나옴. (LIFO)  
> 함수 안에서 함수가 호출되면 (재귀) 스택과 같은 구조로 동작
>
> - 특정 위치에서만 데이터를 넣고 뺄 수 있음
> -
>
> **사용**
>
> - 컴퓨터 내부의 프로세스의 함수 동작 방식에 사용 (프로세스 스택)  
>   **장점**
> - 구조가 단순해서 구현이 쉽고, 데이터 저장/읽기 속도가 빠름  
>   **단점**
> - 데이터 최대 갯수를 미리 정해야함 (파이썬은 1000번)
> - 저장 공간 낭비가 발생 가능 -> 미리 최대 갯수만큼 저장공간 확보해야해서

> **Priority Queue**는 각 원소들에 우선순위가 있고, 우선순위가 높은 데이터가 먼저 나옴.
>
> - 시뮬레이션 시스템
> - 네트워크 트래픽 제어
> - 멀티태스킹을 위한 운영체제 프로세스 스케쥴링 방식을 구현할때 (운영체제)
> - 수치 해석적인 계산

우선순위 큐가 힙이라는 것은 널리 알려진 오류로 우선순위 큐는 "리스트"나 "맵"과 같이 추상적인 개념. 우선순위 큐는 배열,연결리스트로 구현 가능하지만 heap으로 구현하는 것이 가장 효율적.

![시간복잡성](https://user-images.githubusercontent.com/78072370/232095660-ab2ddde2-40f1-4983-bbe5-29f9028c92c2.png)

---

</br>

## 최대 힙 (max heap)

부모노드의 키값이 자식노드의 키값보다 항상 큰 힙  
뿌리노드에 최대값이 옴

## 최소 힙 (min heap)

부모노드의 키값이 자식노드의 키값보다 항상 작은 힙  
뿌리노드에 최소값이 옴

</br>

## 힙의 구현

힙을 배열로 구현 했을때, **i번째 노드**의 왼쪽 자식노드의 위치는 **i\*2**, 오른쪽 자식노드의 위치는 **i\*2+1**이고, 부모 노드의 위치는 **i/2**가 됨. **(단, 배열의 첫번째 인덱스가 1이여야함)**

### 삽입 (최대힙)

1. 배열의 마지막 인덱스(i)에 삽입하려는 값을 넣는다.
2. 해당 자리의 부모 노드(i//2)와 비교해서 부모 노드가 더 작다면 스왑한다.
3. 부모 노드가 더 클때까지 혹은 루트노드가 될때까지 계속해서 2번을 반복한다.

### 삭제 (최대힙)

1. 배열의 가장 첫번째 인덱스 값을 삭제한다.
2. 비어있는 첫번째 인덱스 자리에 배열의 마지막 인덱스 값을 넣는다.
3. 자식 노드 2개를 비교해서 더 큰 자식노드를 결정하고, 더 큰 자식 노드와 첫번째 인덱스 값을 비교한다. 이때 첫번째 인덱스 값이 더 작다면 스왑한다.
4. 스왑한 경우 부모 노드가 더 큰 자식 노드보다 클때 까지 3을 반복한다.

힙의 삽입과 삭제는 모두 이진 트리의 높이와 관련 있기 때문에 (최대 트리 높이 만큼 비교) 시간 복잡성은 **O(logN)**.

</br>

## In python

파이썬의 `heapq` 모듈 사용. `heapq` 모듈은 배열을 최소힙 처럼 사용할 수 있게 해줌.(따로 자료구조x) 따라서 빈 배열에 원소를 하나하나 넘겨주는 `heappush(배열,원소)`을 해주거나 배열 자체를 힙으로 바꿔주는 `heapify(배열)`을 사용. 삭제는 `heappop()` 사용.  
`heapq`은 최소 힙으로 구현 되어 있기때문에 최대 힙을 사용하기 위해서는 값에 음수화를 진행 해 주어야 함.
