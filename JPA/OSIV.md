# @Transactional & OSIV

## 트랜잭션이란?

데이터베이스에서 트랜잭션은 하나의 논리적인 작업 단위.

트랜잭션은 일련의 연산들을 포함하며, 이들 연산은 모두 성공적으로 수행되거나 모두 실패해야함.

<br>

## Spring boot 에서의 트랜잭션 관리

Spring Boot에서 트랜잭션 관리를 하는 방법은 **@Transactional** 어노테이션을 사용하는 것.

해당 어노테이션을 **메서드**나 **클래스**에 적용함으로써 해당 메서드나 클래스가 트랜잭션 범위에서 실행되도록 지정할 수 있음. 즉, @Transactional이 붙은 메서드가 호출되면 Spring은 그 메서드를 실행하는 동안 사용되는 모든 데이터베이스 연산을 하나의 트랜잭션으로 처리 한다.

이를 선언적 트랜잭션 이라고 함.

➕ Tip. 클래스와 메소드에 둘 다 어노테이션이 붙어있다면 더 하위에 붙은 @Transactional 옵션이 적용된다.

<br>

## @Transactional이 작동하는 원리

@Transactional 애너테이션은 Spring의 AOP(Aspect-Oriented Programming)와 트랜잭션 관리자를 기반으로 작동한다. 트랜잭션의 경우, 트랜잭션의 시작과 연산 종료시의 커밋 과정이 필요하므로, 프록시를 생성해 해당 메서드의 앞뒤에 트랜잭션의 시작과 끝을 추가하는 것이다.

[Self-invocation 문제]()

### 트랜잭션과 영속성 컨텍스트

우리는 보통 JPA 에서 하나의 트랜잭션 당 하나의 EntityManager 가 생성되므로

- 1 트랜잭션 == 1 영속성 컨텍스트

라고 생각한다. 그렇다면 스프링부트 환경 속에서도 이 법칙이 통할까?

❗️정답은 반은 맞고 반은 틀림!

스프링 컨테이너는 **트랜잭션 스코프 영속성 컨텍스트 전략**을 기본으로 사용한다. `PersistenceContextType.TRANSACTION`

즉, @Transactional을 사용하면 해당 메서드가 호출 될때 영속성 컨텍스트를 만들고 커밋되면 사라진다는 뜻. 그래서 같은 트랜잭션에 있다면 동일한 영속성 컨텍스트를 사용하게 된다.

❓그런데 왜 반은 틀릴까?

이유는 OSIV 때문이다.

<br>

## OSIV (Open Session On View)

- 영속성 컨텍스트를 뷰까지 열어둔다는 뜻 → 뷰에서 지연 로딩을 가능하게 해준다.
- JPA에서는 OEIV(Open EntityManager In View)라고 부른다.
- 스프링 부트에서는 **기본이 true** 로 설정되어있음

> **Open Session In View의 핵심은 "영속성 컨텍스트와 DB 커넥션이 얼마나 유지되는가" 이다**

- 클라이언트로부터 요청이 들어오면 트랜잭션 시작 없이 영속성 컨텍스트만 생성.
- 트랜잭션 유무에 따라 수정권한 부여.
- _즉, 서비스 단계에서 2개의 트랜잭션이 열려도 영속성 컨텍스트는 하나만 쓴다._

<br>

### 작동 원리

1. 클라이언트의 요청이 들어오면 서블릿 필터나, 스프링 인터셉터에서 영속성 컨텍스트를 생성한다. 단 이때 트랜잭션은 시작하지는 않는다. -> 서블릿 필터 or 인터셉터. 어디서 시작할지는 제공되는 OSIV 라이브러리를 통해 선택 가능.
2. 서비스 계층에서 @Transactional로 트랜잭션을 시작할 때 1번에서 미리 생성해둔 영속성 컨텍스트를 찾아와서 트랜잭션을 시작한다.
3. 서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 이때 트랜잭션은 끝내지만 영속성 컨텍스트는 종료하지 않는다.
4. 컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속 상태를 유지한다.
5. 서블릿 필터나, 스프링 인터셉터로 요청이 들어오면 영속성 컨텍스트를 종료한다. 이때 플러시를 호출하지 않고 바로 종료한다.

**같은 HTTP 요청은 같은 영속성 컨텍스트를 쓰게 된다.
→ 그러므로 트랜잭션이 달라도 같은 영속성 컨텍스트를 쓰게 된다.**

<br>

> 과거에는 **요청 당 트랜잭션 방식의 OSIV**를 사용해서 Presentation 계층에서 Entity를 바꿀 수 있는 문제가 있었지만, spring boot는 위같은 **비즈니스 계층 트랜잭션 방식의 OSIV**를 사용해 이런 문제가 발생하지 않는다.

> ❗️비즈니스 계층 트랜잭션 방식의 OSIV
> ![ㄴ](https://github.com/happyjamy/TIL/assets/78072370/0f96a857-12f5-4536-8cc0-92669fe86a48)
> 영속성 컨텍스트를 통한 변경은 트랜잭션이 있어야만 실행되고, 단순 조회는 트랜잭션이 없어도 DB 커넥션이 유지되고 있기때문에 가능하게함.
> -> "트랜잭션 없이 읽기 (NonTransactional read)"

<br>

### OSIV에서 발생할 수 있는 이슈

1. OSIV 옵션을 true 로 해놓으면 DB 커넥션이 길게 유지 되어 성능 문제가 있을 수 있다.
2. 트랜잭션 마다 다른 영속성 컨텍스트를 쓰는줄 알고 코드를 작성했다가 기대한대로 동작하지 않을 수 있다.
3. 트랜잭션을 열기 전 레이어에서의 변경 사항이 반영될 수 있다
   -> 해당 문제는 레이어 계층의 역할을 엄격하게 분리하고, 자각을 가지고 쓴다면 해결 가능.

<br>

### 1. OSIV 옵션을 true 로 해놓으면 DB 커넥션이 길게 유지 되어 성능 문제가 있을 수 있다.

결국 DB 커넥션이 presentation 계층 이전부터 response 갈때까지 유지되는 것이므로, 동시에 많은 요청을 처리해야 하는 환경에서는 DB 커넥션 부족 문제를 유발.
현재 본인이 개발하는 API는 라운드트립이 1.5초 정도 걸리는데 그러면 1.5초 동안 DB 커넥션은 반납이 안되는 것이다.

### 2. 트랜잭션 마다 다른 영속성 컨텍스트를 쓰는줄 알고 코드를 작성했다가 기대한대로 동작하지 않을 수 있다.

본인이 겪은 에러 : [왜 트랜잭션은 Service 계층에 붙여야 하나요?]()  
내가 겪은 에러 말고도 rollback 을 할때도 문제가 발생한다. 트랜잭션을 rollback 하는 것은 결국 데이터베이스 반영사항을 복구하는 것이지 영속성 컨텍스트 속 Entity를 복구 하는 개념은 아니다. OSIV를 사용하고 하나의 request에 2개의 트랜잭션이 실행된다면, 앞에 트랜잭션이 에러로 rollback 되면 뒤에 트랜잭션은 그대로 변경 된 Entity가 든 영속성 컨텍스트를 쓰게 될 수 도 있다는 것.

- 트랜잭션이 롤백 된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다.
- spring boot에서는 이런 문제를 예방하기 위해 영속성 컨텍스트의 범위에 따라 다른 방식을 사용
  - spring boot 기본 전략이 트랜잭션 스코프 영속성 컨텍스트이기 때문에 이때 문제가 발생하면 트랜잭션이 AOP 종료시점에 트랜잭션을 rollback 하면서 영속성 컨텍스트도 종료시킨다.
  - 이게 OSIV를 사용할땐 안먹힘.
- 그래서 spring boot 는 트랜잭션보다 영속성컨텍스트를 넓게 가져갈때는 **트랜잭션 rollback 시 영속성 컨텍스트를 clear 한다.** `doRollBack` 메소드 참고.

<br>

### ⭕️ 최종적 해결법

## **OSIV** 를 끈다!

-> 더 효율적으로 DB 커넥션을 관리 가능.  
하지만 OSIV를 끄면 예상치 못한 문제가 발생 가능.

- 지연로딩 -> 알아서 트랜잭션 안에서 강제 호출 해야함

이때 복잡성을 관리하게 편하게 Command Query 를 분리하라고 (김영한님이) 권고.

> Command Query Seperation:
> 읽기 작업 (Query)과 쓰기 작업 (Command)을 서로 분리하는 전략

보통 성능 이슈와 복잡한 쿼리는 조회에서 많이 발생

- ex. 내 위치 기반으로 반경 3km 안에 있는 빨간색 물건 다 조회해줘 -> 사망

이런 복잡한 쿼리는 특정 기능에 맞추어져 있기때문에 핵심 비즈니스에 큰 영향을 주지 않음.
핵심 비즈니스용 쿼리와 복잡한 조회 쿼리를 같은 레포에 넣으면 유지보수 폭망 -> 라이프사이클이 다름.
또한 조회용 레포는 `@Transactional(readOnly = true)` 을 넣어 성능도 챙겨가자.
